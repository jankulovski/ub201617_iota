## Motivation

Implement a genetic algorithm to evolve agents that move through a hilly terrain. <br/>
The terrain is a 2-dimensional array where the value of each cell represents the height.<br/>
Agents can only move forward or backward and turn left or right.<br/>
As the agents execute moves, the move_counter increases depending on the difference in height between the starting and ending cell.<br/>
The agents can also perform tests and execute moves depending on the result.<br/>
Define N possible movement commands and number them 0-N.<br/>
Their goal is to cover as much ground as possible with the given number of moves.<br/>

A typical genetic algorithm can be defined with following:

- Generates a population of points at each iteration. The best individual in the population approaches an optimal solution.<br/>
- Selects the next population by evolving the current population using crossover and mutation functions.<br/>
- Every individual have its own fitness evaluation function which defines his efficiency in the given domain.<br/>
- Fitness function is used in evolution of the population.<br/>
- Is using predefined thresholds such population size, number of iterations, tournament size, mutation rate etc.<br/>

## Implementation

Genetic algorithm [See Evolution](#project-classes-and-definitions) (for detailed description of functions definitions): <br/>
1. Generating first population of agents. <br/>
2. Each agent of the population runs on his terrain (terrains can be found in [hills folder - hill_*.txt](hill/hills)) with the predefined program and compute his own fitness function based on the actions and costs.
Agent executes actions until he runs out of `Money` (move_counter) or out of steps `Max iterations` . Money are deducted depending on the difference in height between his current and next cell.<br/>
3. In next step the average fitness function is computed for the population and the best agent is chosen based on the fitness function. <br/>
4. After the average fitness and best agent is selected, new population is generated using the `crossover` function and `mutation` function.
Crossover function takes two parent agents chosen by `tournament selection` or `wheel selection` (we implemented both) function. Mutation function is performed over the new generated agent as result of crossover function.<br/>
5. Fitness is calculated once again for each agent, the average fitness for the population is calculated and the best agent is chosen.<br/>
6. Fifth step is repeated N iterations (N is defined as `Num of generation` ([See Initialization](#project-classes-and-definitions)). Every iteration the population is evolving and appraching the optimal solution.
7. Best average fitness and best agent are returned as solution after N iterations

## Project classes and definitions

`Initialization` thresholds that can be changed [Initialization.py](hill/initialization.py):<br/>
- Max iterations<br/>
- Money<br/>
- Population size<br/>
- Num of generation<br/>
- Tournament size<br/>
- Mutation rate<br/>
- Hill(terrain)<br/>

`Agents` are defined as objects with following attributes [Agent class](hill/simulator.py):
- Commands 
```
CMDS = [
"nop()",
"move_forward()",
"move_backward()",
"turn_left()",
"turn_right()",
"set_flag()",
"clear_flag()",
"mark_position()",
"unmark_position()"]
```
```
TESTS = [
"coverage_improved()",
"can_move_forward",
"can_move_backward",
"marked_ahead",
"marked_behind",
"marked_current",
"flag"]
```
- Program - Random generated commands
- Terrain or Hill (in 2D)
- Max moves allowed
- Money or Cost
- Fitness (function definition can be found in [simulator.py - Agent class](hill/simulator.py)

`Hills` are the terrains defined where the agents can execute actions/commands
- Terrains can be found in [hills folder - hill_*.txt](hill/hills). They are randomly generated by [generator.py](hill/generator.py).

`Evolution` class [evolution.py](hill/evolution.py) defines the main functions of the genetic algorithm
`generate_random_generation` - Generates initial random generation with random program for each agent
`regenerate_generation` - Regenerate new population based on the current one using crossover and mutation functions.
`program_combinations` - Generate random program for the agent with actions/commands.
`crossover (Single point crossover), crossover2, crossover3` - We implemented three different crossover functions. See more details about crossover functions [here](https://en.wikipedia.org/wiki/Crossover_(genetic_algorithm))
`mutation` - After the new agent is generated by the crossover function, mutation function alters one or more values in an agent from its initial state. See more details about mutation function [here](https://en.wikipedia.org/wiki/Mutation_(genetic_algorithm))
`tourn_selection`  - function for selecting two parents for crossover. See more details about tournament selection function [here](https://en.wikipedia.org/wiki/Tournament_selection)
`wheel_selection` - function for selecting two parents for crossover. See more details about Roulette wheel selection function [here](http://www.edc.ncl.ac.uk/highlight/rhjanuary2007g02.php)


## Testing and results

We tested three different crossover functions and two different selection functions (tournament and Roulette wheel).

`First test` - tournament selection with first "crossover" function (Single point crossover)

Last generations resulted with same average fitness and best fitness for agent:

...<br/>
Generation: 47, Average Fitness: 15, Best 17<br/>
Generation: 48, Average Fitness: 15, Best 17<br/>
Generation: 49, Average Fitness: 15, Best 17<br/>

Plots: <br/>
[Average fitness per generation using tournament selection, first Singe point crossover function and mutation function](hill/tests/TournamentCrossover1AverageFitnessPerPopulation.JPG) <br/>
[Best fitness per generation using tournament selection, first Singe point crossover function and mutation function](hill/tests/TournamentCrossover1BestFitnessPerPopulation.JPG) <br/>
